{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Spatial Interaction with Spatial Dependence\n",
        "jupyter: conda-env-nersa25-py\n",
        "---"
      ],
      "id": "3161a201"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import geopandas as gpd\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import scipy\n",
        "from formulaic import Formula\n",
        "from geosnap import DataStore\n",
        "from geosnap import io as gio\n",
        "from libpysal.graph import Graph\n",
        "from shapely import LineString\n",
        "from spreg import GMM_Error, GM_Lag\n",
        "%load_ext watermark\n",
        "%watermark -a 'eli knaap'"
      ],
      "id": "3cbf15d8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "What if our flows are not independent?\n",
        "\n",
        "Like any regression, a critical assumption in spatial interaction models\n",
        "is that observations are *independent* from one another. And like any model\n",
        "using spatial data, the model is misspecified if residuals are spatially\n",
        "autocorrelated (indicating the input data fail the independence criterion). We\n",
        "can use spatial econometric approaches to handle this situation, albeit with\n",
        "some minor modifications because\n",
        "\n",
        "- autocorrelation may come from origins, destinations, or both\n",
        "- we need to approximate the data using a log-linear model instead of proper Poisson\n",
        "\n",
        "Approaches for estimating spatial lag models are described in\n",
        "@lesage2007KnowledgeSpillovers and @lesage2008SpatialEconometric while error\n",
        "models are decribed by @fischer2008ModelingSpatial, the latter two of which use\n",
        "conventional estimation techniques with specialized $W$ matrices based on the\n",
        "notion of neighboring origins or neighboring destinations. We explore how to\n",
        "conduct these analyses below. For further background, consult\n",
        "@fischer2008ModelingSpatial, @lesage2007KnowledgeSpillovers,\n",
        "@lesage2008SpatialEconometric, @lesage2010SpatialEconometric,\n",
        "@lesage2013SpatialInteraction, @lesage2014WhatRegional,\n",
        "@thomas-agnan2014SpatialEconometric @ord1975EstimationMethods.\n",
        "\n",
        "## Spatial Econometric Models\n",
        "\n",
        "In the following example we will focus on the spatial interaction specificaiton of two workhorse models in spatial econometrics: the \"spatial lag\" and \"spatial error\" models. Following the log-linear specification from the prior section, these are given by\n",
        "\n",
        "### Spatial Lag\n",
        "\n",
        "$$ \\log(F_{ij} + \n",
        "\\delta) =  \\log(\\kappa) + \\rho W\\log(F_{ij}+\\delta) + \\alpha \\log(O_i)  + \\beta \\log(D_j) + \\gamma d_{ij} + \\epsilon_{ij} $$\n",
        "\n",
        "### Spatial Error\n",
        "\n",
        "$$ \\log(F_{ij} + \n",
        "\\delta) = \\log(\\kappa) +  \\alpha \\log(O_i)  + \\beta \\log(D_j) + \\gamma d_{ij} + u $$\n",
        "\n",
        "$$ u = \\lambda Wu +\\epsilon_{ij} $$\n",
        "\n",
        "## Data Preparation\n",
        "\n",
        "We will follow the same data processing steps as in the previous sections,\n",
        "collecting data for Washington D.C. and converting it into a matrix of flows."
      ],
      "id": "3a5bfbd3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "datasets = DataStore()\n",
        "\n",
        "dc = gio.get_acs(datasets, state_fips=\"11\", years=2021, level=\"tract\")\n",
        "\n",
        "dc_flows = pd.read_csv(\n",
        "    \"https://lehd.ces.census.gov/data/lodes/LODES8/dc/od/dc_od_main_JT00_2022.csv.gz\",\n",
        "    converters={\"w_geocode\": str, \"h_geocode\": str},\n",
        "    low_memory=False,\n",
        "    encoding=\"latin1\",\n",
        ")\n",
        "dc_flows[\"w_tr_geocode\"] = dc_flows[\"w_geocode\"].str[:11]\n",
        "dc_flows[\"h_tr_geocode\"] = dc_flows[\"h_geocode\"].str[:11]\n",
        "dc_flows = dc_flows[[\"w_geocode\", \"h_geocode\", \"w_tr_geocode\", \"h_tr_geocode\", \"S000\"]]\n",
        "dc_flows = (\n",
        "    dc_flows.groupby([\"w_tr_geocode\", \"h_tr_geocode\"])[\"S000\"].sum().reset_index()\n",
        ")\n",
        "\n",
        "dc_flow_graph = Graph.from_adjacency(\n",
        "    adjacency=dc_flows,\n",
        "    focal_col=\"h_tr_geocode\",\n",
        "    neighbor_col=\"w_tr_geocode\",\n",
        "    weight_col=\"S000\",\n",
        ")\n",
        "\n",
        "dc = dc.set_index(\"geoid\")\n",
        "\n",
        "# for our dataset we want the full dense matrix\n",
        "dc_interaction = pd.Series(\n",
        "    dc_flow_graph.sparse.toarray().reshape(-1),\n",
        "    index=pd.MultiIndex.from_product(\n",
        "        [dc_flow_graph.unique_ids, dc_flow_graph.unique_ids.rename(\"neighbor\")]\n",
        "    ),\n",
        ").rename(\"weight\")\n",
        "\n",
        "dc_interaction = dc_interaction.reset_index()\n",
        "\n",
        "# first merge origin attributes\n",
        "dc_interaction = dc_interaction.merge(\n",
        "    dc.drop(columns=[\"geometry\"]), left_on=\"focal\", right_index=True, how=\"left\"\n",
        ")\n",
        "\n",
        "# now merge destination attributes\n",
        "dc_interaction = dc_interaction.merge(\n",
        "    dc.drop(columns=[\"geometry\"]),\n",
        "    left_on=\"neighbor\",\n",
        "    right_index=True,\n",
        "    how=\"left\",\n",
        "    suffixes=[\"_origin\", \"_destination\"],\n",
        ")"
      ],
      "id": "c06ecb18",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## A Confluence of `Graphs`\n",
        "\n",
        "What's \"near\" to a *flow*?\n",
        "\n",
        "### Distance Graph\n",
        "\n",
        "keep only tracts in the dataframe in our flow graph (origins), then get distance between observations with no decay"
      ],
      "id": "64d91ace"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dc = dc.to_crs(dc.estimate_utm_crs())\n",
        "\n",
        "dc = dc[dc.index.isin(dc_flow_graph.unique_ids)]\n",
        "\n",
        "dc_dist = Graph.build_distance_band(\n",
        "    dc.set_geometry(dc.centroid), threshold=1e20, binary=False, alpha=1\n",
        ")"
      ],
      "id": "7da5840a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dc_dist.summary()"
      ],
      "id": "69fa0851",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dc_dist.adjacency"
      ],
      "id": "3f528429",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# subset the distance graph by the travel graph (remove destinations we dont need)\n",
        "# but this resets weights to 1\n",
        "dc_dist_adj = dc_dist.intersection(dc_flow_graph).adjacency\n",
        "\n",
        "# update with the old values\n",
        "dc_dist_adj.update(dc_dist.adjacency)\n",
        "\n",
        "dc_interaction[\"distance\"] = dc_dist.sparse.toarray().reshape(-1)\n",
        "\n",
        "dc_interaction['weight'] = dc_interaction['weight'].astype(int)"
      ],
      "id": "323ea1c8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Contiguity Graph"
      ],
      "id": "b5401e6f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "contg = Graph.build_contiguity(dc)"
      ],
      "id": "830f4ddb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "contg"
      ],
      "id": "bc9243e2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Imagine you had a flow that moved from north to south like the map below. The\n",
        "'neighborhood' of this flow might be the tracts surrounding the origin in the\n",
        "north, those surrounding the destination in the south, or a combination thereof."
      ],
      "id": "10ad262d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "focus_tracts = [\"11001007703\", \"11001001804\"]\n",
        "\n",
        "contg.explore(dc.centroid)\n",
        "\n",
        "m = dc.explore(tiles=\"CartoDB Positron\", tooltip=[\"geoid\"])\n",
        "contg.explore(\n",
        "    dc,\n",
        "    m=m,\n",
        "    focal=focus_tracts,\n",
        "    edge_kws=dict(color=\"red\"),\n",
        "    node_kws=dict(style_kwds=dict(radius=4, color=\"yellow\")),\n",
        ")\n",
        "l = gpd.GeoDataFrame(geometry=[LineString(dc.loc[focus_tracts].geometry.centroid.get_coordinates()[['x','y']].values)], crs=dc.crs)\n",
        "l.explore(m=m, color='gray', style_kwds={'weight':5})"
      ],
      "id": "a9e42606",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Spatial Graphs for Origin-Destination Flows\n",
        "\n",
        "the `contg` Graph encodes flows as neighbors if the origin tracts share a border.\n",
        "\n",
        "but we need to multiply that graph to get it into the correct dimensions to\n",
        "match our flow data. Following @lesage2008SpatialEconometric and\n",
        "@fischer2008ModelingSpatial we do this via a\n",
        "[*Kronecker* product](https://en.wikipedia.org/wiki/Kronecker_product) between\n",
        "our flow and contiguity graphs to create the graph ($W$) used in the model.\n",
        "\n",
        "![Kronecker Product](../img/kron.png)\n",
        "\n",
        "$G_{flow} \\otimes G_{cont}$, where $\\otimes$ is the Kronecker product of the\n",
        "flow graph and contiguity graphs that defines connectivity between origin and\n",
        "destination observations.\n",
        "\n",
        "In this case observations are neighbors if:\n",
        "\n",
        "- there is a flow between o and d\n",
        "- if o_i shares a border with o_j\n",
        "- three distinct possibilities depending on how the flow graph is ordered\n",
        "  - origin-centric weights\n",
        "  - destination-centric weights\n",
        "  - OD-centric weights (union or sum of oW and dW)\n",
        "\n",
        "take the Kronecker product of the two Graphs, then re-instantiate a new one"
      ],
      "id": "9a0ad3f8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kg = Graph.from_sparse(scipy.sparse.kron(dc_flow_graph.transform(\"b\").sparse, contg.sparse))"
      ],
      "id": "ce0d8dc2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "our new graph now as the same length as our observation vector"
      ],
      "id": "b5962f6a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kg.n"
      ],
      "id": "8f404656",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dc_interaction.shape[0]"
      ],
      "id": "3aebbb0e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "this is an origin-centric ODW, so to get the destination-centric weights you'd do the transpose of the OD matrix (flow graph) first [@lesage2008SpatialEconometric]"
      ],
      "id": "6c73f0b2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kg.pct_nonzero"
      ],
      "id": "ae3c9d57",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "contg.pct_nonzero"
      ],
      "id": "17233a9e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dc_flow_graph.pct_nonzero"
      ],
      "id": "4b135121",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "row-standardize"
      ],
      "id": "9a380d93"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kg = kg.transform('r')"
      ],
      "id": "e670310b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "`spreg` will only treat the Graph as a matrix, so the ordering of the sparse representation is all that matters, not the indices/labels; i.e. the Graph has the correct shape and order even though the indices of the Graph are different than those of the observations\n",
        "\n",
        "## Main Model Specification\n",
        "\n",
        "> \"Note in some cases yij = 0, indicating the absence of flows from i to j. This\n",
        "> leads to the so-called zero problem, since the logarithm then is undefined.\n",
        "> There are several pragmatic solutions to this problem, with adding a small\n",
        "> constant to the zero elements of [yij ] being widely used. Here we added\n",
        "> 0.08.\" [@fischer2008ModelingSpatial]\n",
        "\n",
        "that gives our $y$ variable a distribution like this"
      ],
      "id": "bd75e92c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dc_interaction.weight.replace(0,0.08).apply(np.log).hist()"
      ],
      "id": "663e2985",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "another common transformation is to add 1 to every observation and take the log of *that*, i.e. take $log(x+1)$"
      ],
      "id": "9b8b8af6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dc_interaction.weight.apply(np.log1p).hist()"
      ],
      "id": "c532d86a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "we specify a log-linear model using `formulaic` to generate our $y$ and $X$ matrices, then pass these to different kinds of spatial econometric models"
      ],
      "id": "4633b7c6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "form = \"np.log1p(weight) ~ 1+ np.log1p(n_total_pop_origin) + np.log1p(median_household_income_origin) + np.log1p(p_nonhisp_black_persons_origin) + np.log1p(n_total_pop_destination) + np.log1p(median_household_income_destination) + np.log1p(p_nonhisp_black_persons_destination) + np.log1p(distance)\""
      ],
      "id": "82f721f1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = Formula(form)\n",
        "\n",
        "# mean-impute missing values and replace any zeros with 0.08 for convenience\n",
        "y, x = f.get_model_matrix(\n",
        "    dc_interaction.fillna(dc_interaction.mean(numeric_only=True))#.replace(0, 0.08)\n",
        ")"
      ],
      "id": "3471cf3f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "scrolled": true
      },
      "source": [
        "y"
      ],
      "id": "f54aa721",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Spatial Lag\n",
        "\n",
        "### Origin centric weights"
      ],
      "id": "139b4c3a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "flow_lag = GM_Lag(y=y, x=x, w=kg, robust='white')"
      ],
      "id": "fdcd8f14",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "scrolled": true
      },
      "source": [
        "print(flow_lag.summary)"
      ],
      "id": "cc0ef8f7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "flow_lag.output"
      ],
      "id": "52f7c475",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pd.Series(flow_lag.u.flatten()).hist()"
      ],
      "id": "8a7fad19",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Destination-centric weights"
      ],
      "id": "f56a5055"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kgd = Graph.from_sparse(scipy.sparse.kron(dc_flow_graph.transform(\"b\").sparse.transpose(), contg.sparse))"
      ],
      "id": "24a6edee",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kgd = kgd.transform('r')"
      ],
      "id": "9d20788b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kgd.pct_nonzero"
      ],
      "id": "b545852c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dest_flow_lag = GM_Lag(y=y, x=x,  w=kgd)"
      ],
      "id": "d27d4cac",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "scrolled": true
      },
      "source": [
        "print(dest_flow_lag.summary)"
      ],
      "id": "f8e33ed5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dest_flow_lag.output"
      ],
      "id": "4e00ff83",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### OD-centric weights\n",
        "\n",
        "one \"OD-graph\" could be the union of the two; a flow is 'neighbors' with another flow if it is contiguous with *either* origin or destination points"
      ],
      "id": "1654263d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kg_od = kg.transform('b').union(kgd.transform('b'))"
      ],
      "id": "71ce8a55",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kg_od = kg_od.transform('r')"
      ],
      "id": "d78e5d65",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kg_od.pct_nonzero"
      ],
      "id": "f41265dc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "od_flow_lag = GM_Lag(y=y, x=x, w=kg_od)"
      ],
      "id": "bb37a6ad",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(od_flow_lag.summary)"
      ],
      "id": "52e29800",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "od_flow_lag.output"
      ],
      "id": "a502519c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Instead, we could take the sum of the two graphs, in which case you are neighbors when contiguous with *either* origin or destination points (same cardinalities as above), but the strength of the weight is 2x if you neighbor *both* origin and destination."
      ],
      "id": "602e7323"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kg_od = Graph.from_sparse(kg.transform('b').sparse + kgd.transform('b').sparse)\n",
        "kg_od = kg_od.transform('r')"
      ],
      "id": "cc01416d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(od_flow_lag.summary)"
      ],
      "id": "5c6e7c18",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "od_flow_lag.output"
      ],
      "id": "5607dd37",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Spatial Error\n",
        "\n",
        "the error models take a really long time to estimate\n",
        "\n",
        "### Origin-Centric"
      ],
      "id": "4f9697f6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "flow_error_origin = GMM_Error(y=y, x=x, w=kg)"
      ],
      "id": "f458df4b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(flow_error_origin.summary)"
      ],
      "id": "384a51e9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "flow_error_origin.output"
      ],
      "id": "20b56553",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Destination-centric"
      ],
      "id": "3668dcb3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "flow_error_dest = GMM_Error(y=y, x=x, w=kgd)"
      ],
      "id": "78c8d9d7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(flow_error_dest.summary)"
      ],
      "id": "14bef6b3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "flow_error_dest.output"
      ],
      "id": "8e7da2ab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### OD-Centric"
      ],
      "id": "8e12e75e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "flow_error_od = GMM_Error(y=y, x=x, w=kg_od)"
      ],
      "id": "f22a9eec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(flow_error_od.summary)"
      ],
      "id": "58774c2c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "flow_error_od.output"
      ],
      "id": "0e7489f2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: callout-note :::\n",
        "\n",
        "As an alternative to the spatial econometric specifications illustrated above,\n",
        "@liao2025DataDrivenApproach recently described a different model that\n",
        "incorporates the \"intervening opportunities\" and \"competing destinations\"\n",
        "frameworks discussed in the spatial interaction literature by incorporating two\n",
        "additional terms $A_i$ and $A_j$ which represent accessibility measures at the\n",
        "origin and destination locations, respectively. In spatial econometric parlance,\n",
        "this approach is equivalent to a spatial lag of X (SLX) model with terms that\n",
        "include both origin-centric and destination-centric lagged X variables. \n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "## References\n"
      ],
      "id": "f1210b32"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "conda-env-nersa25-py",
      "language": "python",
      "display_name": "Python [conda env:nersa25]",
      "path": "/Users/knaaptime/Library/Jupyter/kernels/conda-env-nersa25-py"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}